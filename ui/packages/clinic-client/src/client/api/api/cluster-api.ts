/* tslint:disable */
/* eslint-disable */
/**
 * Clinic Example API
 * This is a Clinic server.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ClusterCluster } from '../models';
// @ts-ignore
import { ClusterDataSummaryResponse } from '../models';
// @ts-ignore
import { ClusterDataUrl } from '../models';
// @ts-ignore
import { ClusterFileMeta } from '../models';
// @ts-ignore
import { ClusterListClustersResp } from '../models';
// @ts-ignore
import { ClusterUpdateClusterReq } from '../models';
// @ts-ignore
import { CommonRebuild } from '../models';
// @ts-ignore
import { CommonSuccessResp } from '../models';
// @ts-ignore
import { CommonTaskStatusResp } from '../models';
/**
 * ClusterApi - axios parameter creator
 * @export
 */
export const ClusterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * list dashboard user can access
         * @summary list dashboard user can access
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} [startTime] startTime of dashboard show
         * @param {number} [endTime] endTime of dashboard show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDashboardGet: async (xCsrfToken: string, oid: string, cid: string, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidDashboardGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidDashboardGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidDashboardGet', 'cid', cid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/dashboard`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get the detail information of the specified timerange in cluster
         * @summary get the detail information of the specified timerange in cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} [startTime] start time
         * @param {number} [endTime] end time
         * @param {number} [limit] the count per page
         * @param {number} [page] the page index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDataGet: async (xCsrfToken: string, oid: string, cid: string, startTime?: number, endTime?: number, limit?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidDataGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidDataGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidDataGet', 'cid', cid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/data`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get data status of the specified cluster
         * @summary get data status of the cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} startTime startTime
         * @param {number} endTime endTime
         * @param {1 | 2 | 3 | 4} dataType int enums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDataStatusGet: async (xCsrfToken: string, oid: string, cid: string, startTime: number, endTime: number, dataType: 1 | 2 | 3 | 4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidDataStatusGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidDataStatusGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidDataStatusGet', 'cid', cid)
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('orgsOidClustersCidDataStatusGet', 'startTime', startTime)
            // verify required parameter 'endTime' is not null or undefined
            assertParamExists('orgsOidClustersCidDataStatusGet', 'endTime', endTime)
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('orgsOidClustersCidDataStatusGet', 'dataType', dataType)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/data_status`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete cluster and data
         * @summary delete cluster and data
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDelete: async (xCsrfToken: string, oid: string, cid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidDelete', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidDelete', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidDelete', 'cid', cid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download file
         * @summary download total package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDownloadConfItemidGet: async (xCsrfToken: string, oid: string, cid: string, itemid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadConfItemidGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadConfItemidGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadConfItemidGet', 'cid', cid)
            // verify required parameter 'itemid' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadConfItemidGet', 'itemid', itemid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/downloadConf/{itemid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)))
                .replace(`{${"itemid"}}`, encodeURIComponent(String(itemid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * download file
         * @summary download total package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDownloadItemidGet: async (xCsrfToken: string, oid: string, cid: string, itemid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadItemidGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadItemidGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadItemidGet', 'cid', cid)
            // verify required parameter 'itemid' is not null or undefined
            assertParamExists('orgsOidClustersCidDownloadItemidGet', 'itemid', itemid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/download/{itemid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)))
                .replace(`{${"itemid"}}`, encodeURIComponent(String(itemid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list packages of the specified cluster
         * @summary List info of the specified cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidGet: async (xCsrfToken: string, oid: string, cid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidGet', 'cid', cid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * meta information of package file
         * @summary meta information of package file
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidItemidMetaGet: async (xCsrfToken: string, oid: string, cid: string, itemid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidItemidMetaGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidItemidMetaGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidItemidMetaGet', 'cid', cid)
            // verify required parameter 'itemid' is not null or undefined
            assertParamExists('orgsOidClustersCidItemidMetaGet', 'itemid', itemid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/{itemid}/meta`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)))
                .replace(`{${"itemid"}}`, encodeURIComponent(String(itemid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get log url
         * @summary log url
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {number} [startTime] startTime of dashboard show
         * @param {number} [endTime] endTime of dashboard show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidLogurlItemidGet: async (xCsrfToken: string, oid: string, cid: string, itemid: string, startTime?: number, endTime?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidLogurlItemidGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidLogurlItemidGet', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidLogurlItemidGet', 'cid', cid)
            // verify required parameter 'itemid' is not null or undefined
            assertParamExists('orgsOidClustersCidLogurlItemidGet', 'itemid', itemid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/logurl/{itemid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)))
                .replace(`{${"itemid"}}`, encodeURIComponent(String(itemid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = endTime;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update cluster information
         * @summary update cluster information
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {ClusterUpdateClusterReq} cluster cluster information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidPut: async (xCsrfToken: string, oid: string, cid: string, cluster: ClusterUpdateClusterReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidPut', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidPut', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidPut', 'cid', cid)
            // verify required parameter 'cluster' is not null or undefined
            assertParamExists('orgsOidClustersCidPut', 'cluster', cluster)
            const localVarPath = `/orgs/{oid}/clusters/{cid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cluster, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * rebuild data for the specified package
         * @summary rebuild data for the specified package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {CommonRebuild} rebuild rebuild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidRebuildPut: async (xCsrfToken: string, oid: string, cid: string, rebuild: CommonRebuild, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidRebuildPut', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidRebuildPut', 'oid', oid)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidRebuildPut', 'cid', cid)
            // verify required parameter 'rebuild' is not null or undefined
            assertParamExists('orgsOidClustersCidRebuildPut', 'rebuild', rebuild)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/rebuild`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rebuild, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get slow log list in cluster
         * @summary get slow log list
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} itemID package id
         * @param {string} cid cluster id
         * @param {number} [beginTime] start time
         * @param {number} [endTime] end time
         * @param {Array<string>} [db] db list
         * @param {number} [limit] limit
         * @param {string} [text] text
         * @param {string} [orderBy] orderBy
         * @param {boolean} [desc] desc
         * @param {Array<string>} [plans] plans
         * @param {string} [digest] digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidSlowqueriesGet: async (xCsrfToken: string, oid: string, itemID: string, cid: string, beginTime?: number, endTime?: number, db?: Array<string>, limit?: number, text?: string, orderBy?: string, desc?: boolean, plans?: Array<string>, digest?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesGet', 'oid', oid)
            // verify required parameter 'itemID' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesGet', 'itemID', itemID)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesGet', 'cid', cid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/slowqueries`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemID !== undefined) {
                localVarQueryParameter['itemID'] = itemID;
            }

            if (beginTime !== undefined) {
                localVarQueryParameter['begin_time'] = beginTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (db) {
                localVarQueryParameter['db'] = db.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (desc !== undefined) {
                localVarQueryParameter['desc'] = desc;
            }

            if (plans) {
                localVarQueryParameter['plans'] = plans.join(COLLECTION_FORMATS.csv);
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get slow log detail in cluster
         * @summary get slow log detail
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} itemID package id
         * @param {string} cid cluster id
         * @param {string} queryid log id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidSlowqueriesQueryidGet: async (xCsrfToken: string, oid: string, itemID: string, cid: string, queryid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesQueryidGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesQueryidGet', 'oid', oid)
            // verify required parameter 'itemID' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesQueryidGet', 'itemID', itemID)
            // verify required parameter 'cid' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesQueryidGet', 'cid', cid)
            // verify required parameter 'queryid' is not null or undefined
            assertParamExists('orgsOidClustersCidSlowqueriesQueryidGet', 'queryid', queryid)
            const localVarPath = `/orgs/{oid}/clusters/{cid}/slowqueries/{queryid}`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)))
                .replace(`{${"cid"}}`, encodeURIComponent(String(cid)))
                .replace(`{${"queryid"}}`, encodeURIComponent(String(queryid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemID !== undefined) {
                localVarQueryParameter['itemID'] = itemID;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list cluster of the specified organization
         * @summary List clusters
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {number} [limit] the count per page
         * @param {string} [query] the query of cluster
         * @param {number} [page] the page index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersGet: async (xCsrfToken: string, oid: string, limit?: number, query?: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xCsrfToken' is not null or undefined
            assertParamExists('orgsOidClustersGet', 'xCsrfToken', xCsrfToken)
            // verify required parameter 'oid' is not null or undefined
            assertParamExists('orgsOidClustersGet', 'oid', oid)
            const localVarPath = `/orgs/{oid}/clusters`
                .replace(`{${"oid"}}`, encodeURIComponent(String(oid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xCsrfToken !== undefined && xCsrfToken !== null) {
                localVarHeaderParameter['x-csrf-token'] = String(xCsrfToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClusterApi - functional programming interface
 * @export
 */
export const ClusterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClusterApiAxiosParamCreator(configuration)
    return {
        /**
         * list dashboard user can access
         * @summary list dashboard user can access
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} [startTime] startTime of dashboard show
         * @param {number} [endTime] endTime of dashboard show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidDashboardGet(xCsrfToken: string, oid: string, cid: string, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClusterDataUrl>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidDashboardGet(xCsrfToken, oid, cid, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get the detail information of the specified timerange in cluster
         * @summary get the detail information of the specified timerange in cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} [startTime] start time
         * @param {number} [endTime] end time
         * @param {number} [limit] the count per page
         * @param {number} [page] the page index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidDataGet(xCsrfToken: string, oid: string, cid: string, startTime?: number, endTime?: number, limit?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterDataSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidDataGet(xCsrfToken, oid, cid, startTime, endTime, limit, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get data status of the specified cluster
         * @summary get data status of the cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} startTime startTime
         * @param {number} endTime endTime
         * @param {1 | 2 | 3 | 4} dataType int enums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidDataStatusGet(xCsrfToken: string, oid: string, cid: string, startTime: number, endTime: number, dataType: 1 | 2 | 3 | 4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonTaskStatusResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidDataStatusGet(xCsrfToken, oid, cid, startTime, endTime, dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete cluster and data
         * @summary delete cluster and data
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidDelete(xCsrfToken: string, oid: string, cid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidDelete(xCsrfToken, oid, cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * download file
         * @summary download total package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidDownloadConfItemidGet(xCsrfToken: string, oid: string, cid: string, itemid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidDownloadConfItemidGet(xCsrfToken, oid, cid, itemid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * download file
         * @summary download total package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidDownloadItemidGet(xCsrfToken: string, oid: string, cid: string, itemid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidDownloadItemidGet(xCsrfToken, oid, cid, itemid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list packages of the specified cluster
         * @summary List info of the specified cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidGet(xCsrfToken: string, oid: string, cid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterCluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidGet(xCsrfToken, oid, cid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * meta information of package file
         * @summary meta information of package file
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidItemidMetaGet(xCsrfToken: string, oid: string, cid: string, itemid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterFileMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidItemidMetaGet(xCsrfToken, oid, cid, itemid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get log url
         * @summary log url
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {number} [startTime] startTime of dashboard show
         * @param {number} [endTime] endTime of dashboard show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidLogurlItemidGet(xCsrfToken: string, oid: string, cid: string, itemid: string, startTime?: number, endTime?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterDataUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidLogurlItemidGet(xCsrfToken, oid, cid, itemid, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update cluster information
         * @summary update cluster information
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {ClusterUpdateClusterReq} cluster cluster information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidPut(xCsrfToken: string, oid: string, cid: string, cluster: ClusterUpdateClusterReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidPut(xCsrfToken, oid, cid, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * rebuild data for the specified package
         * @summary rebuild data for the specified package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {CommonRebuild} rebuild rebuild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidRebuildPut(xCsrfToken: string, oid: string, cid: string, rebuild: CommonRebuild, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonSuccessResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidRebuildPut(xCsrfToken, oid, cid, rebuild, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get slow log list in cluster
         * @summary get slow log list
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} itemID package id
         * @param {string} cid cluster id
         * @param {number} [beginTime] start time
         * @param {number} [endTime] end time
         * @param {Array<string>} [db] db list
         * @param {number} [limit] limit
         * @param {string} [text] text
         * @param {string} [orderBy] orderBy
         * @param {boolean} [desc] desc
         * @param {Array<string>} [plans] plans
         * @param {string} [digest] digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidSlowqueriesGet(xCsrfToken: string, oid: string, itemID: string, cid: string, beginTime?: number, endTime?: number, db?: Array<string>, limit?: number, text?: string, orderBy?: string, desc?: boolean, plans?: Array<string>, digest?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidSlowqueriesGet(xCsrfToken, oid, itemID, cid, beginTime, endTime, db, limit, text, orderBy, desc, plans, digest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get slow log detail in cluster
         * @summary get slow log detail
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} itemID package id
         * @param {string} cid cluster id
         * @param {string} queryid log id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersCidSlowqueriesQueryidGet(xCsrfToken: string, oid: string, itemID: string, cid: string, queryid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersCidSlowqueriesQueryidGet(xCsrfToken, oid, itemID, cid, queryid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list cluster of the specified organization
         * @summary List clusters
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {number} [limit] the count per page
         * @param {string} [query] the query of cluster
         * @param {number} [page] the page index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOidClustersGet(xCsrfToken: string, oid: string, limit?: number, query?: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterListClustersResp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOidClustersGet(xCsrfToken, oid, limit, query, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClusterApi - factory interface
 * @export
 */
export const ClusterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClusterApiFp(configuration)
    return {
        /**
         * list dashboard user can access
         * @summary list dashboard user can access
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} [startTime] startTime of dashboard show
         * @param {number} [endTime] endTime of dashboard show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDashboardGet(xCsrfToken: string, oid: string, cid: string, startTime?: number, endTime?: number, options?: any): AxiosPromise<Array<ClusterDataUrl>> {
            return localVarFp.orgsOidClustersCidDashboardGet(xCsrfToken, oid, cid, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * get the detail information of the specified timerange in cluster
         * @summary get the detail information of the specified timerange in cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} [startTime] start time
         * @param {number} [endTime] end time
         * @param {number} [limit] the count per page
         * @param {number} [page] the page index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDataGet(xCsrfToken: string, oid: string, cid: string, startTime?: number, endTime?: number, limit?: number, page?: number, options?: any): AxiosPromise<ClusterDataSummaryResponse> {
            return localVarFp.orgsOidClustersCidDataGet(xCsrfToken, oid, cid, startTime, endTime, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * get data status of the specified cluster
         * @summary get data status of the cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {number} startTime startTime
         * @param {number} endTime endTime
         * @param {1 | 2 | 3 | 4} dataType int enums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDataStatusGet(xCsrfToken: string, oid: string, cid: string, startTime: number, endTime: number, dataType: 1 | 2 | 3 | 4, options?: any): AxiosPromise<CommonTaskStatusResp> {
            return localVarFp.orgsOidClustersCidDataStatusGet(xCsrfToken, oid, cid, startTime, endTime, dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * delete cluster and data
         * @summary delete cluster and data
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDelete(xCsrfToken: string, oid: string, cid: string, options?: any): AxiosPromise<string> {
            return localVarFp.orgsOidClustersCidDelete(xCsrfToken, oid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * download file
         * @summary download total package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDownloadConfItemidGet(xCsrfToken: string, oid: string, cid: string, itemid: string, options?: any): AxiosPromise<any> {
            return localVarFp.orgsOidClustersCidDownloadConfItemidGet(xCsrfToken, oid, cid, itemid, options).then((request) => request(axios, basePath));
        },
        /**
         * download file
         * @summary download total package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidDownloadItemidGet(xCsrfToken: string, oid: string, cid: string, itemid: string, options?: any): AxiosPromise<any> {
            return localVarFp.orgsOidClustersCidDownloadItemidGet(xCsrfToken, oid, cid, itemid, options).then((request) => request(axios, basePath));
        },
        /**
         * list packages of the specified cluster
         * @summary List info of the specified cluster
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidGet(xCsrfToken: string, oid: string, cid: string, options?: any): AxiosPromise<ClusterCluster> {
            return localVarFp.orgsOidClustersCidGet(xCsrfToken, oid, cid, options).then((request) => request(axios, basePath));
        },
        /**
         * meta information of package file
         * @summary meta information of package file
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidItemidMetaGet(xCsrfToken: string, oid: string, cid: string, itemid: string, options?: any): AxiosPromise<ClusterFileMeta> {
            return localVarFp.orgsOidClustersCidItemidMetaGet(xCsrfToken, oid, cid, itemid, options).then((request) => request(axios, basePath));
        },
        /**
         * get log url
         * @summary log url
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {string} itemid item id
         * @param {number} [startTime] startTime of dashboard show
         * @param {number} [endTime] endTime of dashboard show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidLogurlItemidGet(xCsrfToken: string, oid: string, cid: string, itemid: string, startTime?: number, endTime?: number, options?: any): AxiosPromise<ClusterDataUrl> {
            return localVarFp.orgsOidClustersCidLogurlItemidGet(xCsrfToken, oid, cid, itemid, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * update cluster information
         * @summary update cluster information
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {ClusterUpdateClusterReq} cluster cluster information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidPut(xCsrfToken: string, oid: string, cid: string, cluster: ClusterUpdateClusterReq, options?: any): AxiosPromise<CommonSuccessResp> {
            return localVarFp.orgsOidClustersCidPut(xCsrfToken, oid, cid, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * rebuild data for the specified package
         * @summary rebuild data for the specified package
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} cid cluster id
         * @param {CommonRebuild} rebuild rebuild
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidRebuildPut(xCsrfToken: string, oid: string, cid: string, rebuild: CommonRebuild, options?: any): AxiosPromise<CommonSuccessResp> {
            return localVarFp.orgsOidClustersCidRebuildPut(xCsrfToken, oid, cid, rebuild, options).then((request) => request(axios, basePath));
        },
        /**
         * get slow log list in cluster
         * @summary get slow log list
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} itemID package id
         * @param {string} cid cluster id
         * @param {number} [beginTime] start time
         * @param {number} [endTime] end time
         * @param {Array<string>} [db] db list
         * @param {number} [limit] limit
         * @param {string} [text] text
         * @param {string} [orderBy] orderBy
         * @param {boolean} [desc] desc
         * @param {Array<string>} [plans] plans
         * @param {string} [digest] digest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidSlowqueriesGet(xCsrfToken: string, oid: string, itemID: string, cid: string, beginTime?: number, endTime?: number, db?: Array<string>, limit?: number, text?: string, orderBy?: string, desc?: boolean, plans?: Array<string>, digest?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.orgsOidClustersCidSlowqueriesGet(xCsrfToken, oid, itemID, cid, beginTime, endTime, db, limit, text, orderBy, desc, plans, digest, options).then((request) => request(axios, basePath));
        },
        /**
         * get slow log detail in cluster
         * @summary get slow log detail
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {string} itemID package id
         * @param {string} cid cluster id
         * @param {string} queryid log id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersCidSlowqueriesQueryidGet(xCsrfToken: string, oid: string, itemID: string, cid: string, queryid: string, options?: any): AxiosPromise<object> {
            return localVarFp.orgsOidClustersCidSlowqueriesQueryidGet(xCsrfToken, oid, itemID, cid, queryid, options).then((request) => request(axios, basePath));
        },
        /**
         * list cluster of the specified organization
         * @summary List clusters
         * @param {string} xCsrfToken get value from login.ValidationResp response
         * @param {string} oid organization id
         * @param {number} [limit] the count per page
         * @param {string} [query] the query of cluster
         * @param {number} [page] the page index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOidClustersGet(xCsrfToken: string, oid: string, limit?: number, query?: string, page?: number, options?: any): AxiosPromise<ClusterListClustersResp> {
            return localVarFp.orgsOidClustersGet(xCsrfToken, oid, limit, query, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOidClustersCidDashboardGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidDashboardGetRequest
 */
export interface ClusterApiOrgsOidClustersCidDashboardGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDashboardGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDashboardGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDashboardGet
     */
    readonly cid: string

    /**
     * startTime of dashboard show
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDashboardGet
     */
    readonly startTime?: number

    /**
     * endTime of dashboard show
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDashboardGet
     */
    readonly endTime?: number
}

/**
 * Request parameters for orgsOidClustersCidDataGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidDataGetRequest
 */
export interface ClusterApiOrgsOidClustersCidDataGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly cid: string

    /**
     * start time
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly startTime?: number

    /**
     * end time
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly endTime?: number

    /**
     * the count per page
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly limit?: number

    /**
     * the page index
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDataGet
     */
    readonly page?: number
}

/**
 * Request parameters for orgsOidClustersCidDataStatusGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidDataStatusGetRequest
 */
export interface ClusterApiOrgsOidClustersCidDataStatusGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDataStatusGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDataStatusGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDataStatusGet
     */
    readonly cid: string

    /**
     * startTime
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDataStatusGet
     */
    readonly startTime: number

    /**
     * endTime
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidDataStatusGet
     */
    readonly endTime: number

    /**
     * int enums
     * @type {1 | 2 | 3 | 4}
     * @memberof ClusterApiOrgsOidClustersCidDataStatusGet
     */
    readonly dataType: 1 | 2 | 3 | 4
}

/**
 * Request parameters for orgsOidClustersCidDelete operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidDeleteRequest
 */
export interface ClusterApiOrgsOidClustersCidDeleteRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDelete
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDelete
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDelete
     */
    readonly cid: string
}

/**
 * Request parameters for orgsOidClustersCidDownloadConfItemidGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidDownloadConfItemidGetRequest
 */
export interface ClusterApiOrgsOidClustersCidDownloadConfItemidGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadConfItemidGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadConfItemidGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadConfItemidGet
     */
    readonly cid: string

    /**
     * item id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadConfItemidGet
     */
    readonly itemid: string
}

/**
 * Request parameters for orgsOidClustersCidDownloadItemidGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidDownloadItemidGetRequest
 */
export interface ClusterApiOrgsOidClustersCidDownloadItemidGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadItemidGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadItemidGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadItemidGet
     */
    readonly cid: string

    /**
     * item id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidDownloadItemidGet
     */
    readonly itemid: string
}

/**
 * Request parameters for orgsOidClustersCidGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidGetRequest
 */
export interface ClusterApiOrgsOidClustersCidGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidGet
     */
    readonly cid: string
}

/**
 * Request parameters for orgsOidClustersCidItemidMetaGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidItemidMetaGetRequest
 */
export interface ClusterApiOrgsOidClustersCidItemidMetaGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidItemidMetaGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidItemidMetaGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidItemidMetaGet
     */
    readonly cid: string

    /**
     * item id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidItemidMetaGet
     */
    readonly itemid: string
}

/**
 * Request parameters for orgsOidClustersCidLogurlItemidGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidLogurlItemidGetRequest
 */
export interface ClusterApiOrgsOidClustersCidLogurlItemidGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidLogurlItemidGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidLogurlItemidGet
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidLogurlItemidGet
     */
    readonly cid: string

    /**
     * item id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidLogurlItemidGet
     */
    readonly itemid: string

    /**
     * startTime of dashboard show
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidLogurlItemidGet
     */
    readonly startTime?: number

    /**
     * endTime of dashboard show
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidLogurlItemidGet
     */
    readonly endTime?: number
}

/**
 * Request parameters for orgsOidClustersCidPut operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidPutRequest
 */
export interface ClusterApiOrgsOidClustersCidPutRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidPut
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidPut
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidPut
     */
    readonly cid: string

    /**
     * cluster information
     * @type {ClusterUpdateClusterReq}
     * @memberof ClusterApiOrgsOidClustersCidPut
     */
    readonly cluster: ClusterUpdateClusterReq
}

/**
 * Request parameters for orgsOidClustersCidRebuildPut operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidRebuildPutRequest
 */
export interface ClusterApiOrgsOidClustersCidRebuildPutRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidRebuildPut
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidRebuildPut
     */
    readonly oid: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidRebuildPut
     */
    readonly cid: string

    /**
     * rebuild
     * @type {CommonRebuild}
     * @memberof ClusterApiOrgsOidClustersCidRebuildPut
     */
    readonly rebuild: CommonRebuild
}

/**
 * Request parameters for orgsOidClustersCidSlowqueriesGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidSlowqueriesGetRequest
 */
export interface ClusterApiOrgsOidClustersCidSlowqueriesGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly oid: string

    /**
     * package id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly itemID: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly cid: string

    /**
     * start time
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly beginTime?: number

    /**
     * end time
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly endTime?: number

    /**
     * db list
     * @type {Array<string>}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly db?: Array<string>

    /**
     * limit
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly limit?: number

    /**
     * text
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly text?: string

    /**
     * orderBy
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly orderBy?: string

    /**
     * desc
     * @type {boolean}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly desc?: boolean

    /**
     * plans
     * @type {Array<string>}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly plans?: Array<string>

    /**
     * digest
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesGet
     */
    readonly digest?: string
}

/**
 * Request parameters for orgsOidClustersCidSlowqueriesQueryidGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersCidSlowqueriesQueryidGetRequest
 */
export interface ClusterApiOrgsOidClustersCidSlowqueriesQueryidGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesQueryidGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesQueryidGet
     */
    readonly oid: string

    /**
     * package id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesQueryidGet
     */
    readonly itemID: string

    /**
     * cluster id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesQueryidGet
     */
    readonly cid: string

    /**
     * log id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersCidSlowqueriesQueryidGet
     */
    readonly queryid: string
}

/**
 * Request parameters for orgsOidClustersGet operation in ClusterApi.
 * @export
 * @interface ClusterApiOrgsOidClustersGetRequest
 */
export interface ClusterApiOrgsOidClustersGetRequest {
    /**
     * get value from login.ValidationResp response
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersGet
     */
    readonly xCsrfToken: string

    /**
     * organization id
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersGet
     */
    readonly oid: string

    /**
     * the count per page
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersGet
     */
    readonly limit?: number

    /**
     * the query of cluster
     * @type {string}
     * @memberof ClusterApiOrgsOidClustersGet
     */
    readonly query?: string

    /**
     * the page index
     * @type {number}
     * @memberof ClusterApiOrgsOidClustersGet
     */
    readonly page?: number
}

/**
 * ClusterApi - object-oriented interface
 * @export
 * @class ClusterApi
 * @extends {BaseAPI}
 */
export class ClusterApi extends BaseAPI {
    /**
     * list dashboard user can access
     * @summary list dashboard user can access
     * @param {ClusterApiOrgsOidClustersCidDashboardGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidDashboardGet(requestParameters: ClusterApiOrgsOidClustersCidDashboardGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidDashboardGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get the detail information of the specified timerange in cluster
     * @summary get the detail information of the specified timerange in cluster
     * @param {ClusterApiOrgsOidClustersCidDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidDataGet(requestParameters: ClusterApiOrgsOidClustersCidDataGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidDataGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.startTime, requestParameters.endTime, requestParameters.limit, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get data status of the specified cluster
     * @summary get data status of the cluster
     * @param {ClusterApiOrgsOidClustersCidDataStatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidDataStatusGet(requestParameters: ClusterApiOrgsOidClustersCidDataStatusGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidDataStatusGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.startTime, requestParameters.endTime, requestParameters.dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete cluster and data
     * @summary delete cluster and data
     * @param {ClusterApiOrgsOidClustersCidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidDelete(requestParameters: ClusterApiOrgsOidClustersCidDeleteRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidDelete(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download file
     * @summary download total package
     * @param {ClusterApiOrgsOidClustersCidDownloadConfItemidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidDownloadConfItemidGet(requestParameters: ClusterApiOrgsOidClustersCidDownloadConfItemidGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidDownloadConfItemidGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.itemid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * download file
     * @summary download total package
     * @param {ClusterApiOrgsOidClustersCidDownloadItemidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidDownloadItemidGet(requestParameters: ClusterApiOrgsOidClustersCidDownloadItemidGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidDownloadItemidGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.itemid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list packages of the specified cluster
     * @summary List info of the specified cluster
     * @param {ClusterApiOrgsOidClustersCidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidGet(requestParameters: ClusterApiOrgsOidClustersCidGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * meta information of package file
     * @summary meta information of package file
     * @param {ClusterApiOrgsOidClustersCidItemidMetaGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidItemidMetaGet(requestParameters: ClusterApiOrgsOidClustersCidItemidMetaGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidItemidMetaGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.itemid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get log url
     * @summary log url
     * @param {ClusterApiOrgsOidClustersCidLogurlItemidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidLogurlItemidGet(requestParameters: ClusterApiOrgsOidClustersCidLogurlItemidGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidLogurlItemidGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.itemid, requestParameters.startTime, requestParameters.endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update cluster information
     * @summary update cluster information
     * @param {ClusterApiOrgsOidClustersCidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidPut(requestParameters: ClusterApiOrgsOidClustersCidPutRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidPut(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * rebuild data for the specified package
     * @summary rebuild data for the specified package
     * @param {ClusterApiOrgsOidClustersCidRebuildPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidRebuildPut(requestParameters: ClusterApiOrgsOidClustersCidRebuildPutRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidRebuildPut(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.cid, requestParameters.rebuild, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get slow log list in cluster
     * @summary get slow log list
     * @param {ClusterApiOrgsOidClustersCidSlowqueriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidSlowqueriesGet(requestParameters: ClusterApiOrgsOidClustersCidSlowqueriesGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidSlowqueriesGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.itemID, requestParameters.cid, requestParameters.beginTime, requestParameters.endTime, requestParameters.db, requestParameters.limit, requestParameters.text, requestParameters.orderBy, requestParameters.desc, requestParameters.plans, requestParameters.digest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get slow log detail in cluster
     * @summary get slow log detail
     * @param {ClusterApiOrgsOidClustersCidSlowqueriesQueryidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersCidSlowqueriesQueryidGet(requestParameters: ClusterApiOrgsOidClustersCidSlowqueriesQueryidGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersCidSlowqueriesQueryidGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.itemID, requestParameters.cid, requestParameters.queryid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list cluster of the specified organization
     * @summary List clusters
     * @param {ClusterApiOrgsOidClustersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClusterApi
     */
    public orgsOidClustersGet(requestParameters: ClusterApiOrgsOidClustersGetRequest, options?: AxiosRequestConfig) {
        return ClusterApiFp(this.configuration).orgsOidClustersGet(requestParameters.xCsrfToken, requestParameters.oid, requestParameters.limit, requestParameters.query, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }
}
